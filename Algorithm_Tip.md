# Algorithm_Tip

**목차**  

[1. 인접 행렬 vs 인접 리스트](#인접-행렬-vs-인접-리스트)
[2. StringTokenizer](#stringtokenizer)
[3. 동적계획법](#동적계획법)

## **알고리즘 분석에 사용하는 대표적인 세 가지 점근적 표기법**

모든 알고리즘 점근적 표기법은 &isin; 대신 = 을 사용한다. 따라서 "표기법 = 점근식" 처럼 사용하면 안된다. "표기법 &isin; 점근식" 이 아니기 때문이다.

점근적 표기법은 입력의 크기가 충분히 큰 경우에 대한 분석이다.

### 1. &theta;-표기법
&theta;(f<sub>(n)</sub>)은 점근적 증가율이 f(n)과 일치하는 모든 함수의 집합이다.

## **재귀**

많은 알고리즘 문제들이 재귀 호출로 풀면 쉽게 풀리는 경우가 있다. 또한 다른 알고리즘 풀이 방법들도 내부적으로 재귀를 호출해 사용하는 것들도 있으니 알아두어야 한다.

재귀는 문제의 특성에 따라 코딩을 훨씬 간편하게 해 줄 수 있다.

### ex1) 중첩 반복문 대체하기

0번부터 차례대로 번호 매겨진 n개의 원소 중 4개를 고르는 모든 경우
ex) n=7이라면, (0,1,2,3), (0,1,2,4), (0,1,2,5), ..., (3,4,5,6)의 경우의 수

```
for(int i=0; i<n; ++i)
    for(int j=i+1; j<n; ++i)
        for(int k=j+1; k<n; ++i)
            for(int l=k+1; l<n; ++i)
                System.out.println(i+" "+j+" "+k+" "+l);
```

5개를 골라야 하는 경우는 5단 중첩문을 사용하면 된다.
6개를 골라야 하는 경우는 6단 중첩문을 사용해야 한다.
이처럼 골라야 하는 원소 수가 증가하면 코드가 길고 복잡해진다. 또한 입력(원소의 수)에 따라 달라질 수 있는 경우에는 사용할 수 없는 코드가 된다.

재귀호출은 이런 경우에 단순한 반복문보다 간결하고 유연한 코드를 작성할 수 있도록 해준다.

위 코드 조각이 하는 작업은 크게 네 개의 조각으로 나눌 수 있다.(각 코드 조각에서 각각 하나의 원소를 고르는 작업) 그러면 이 작업은 하나의 원소를 고르고 남은 원소들을 고르는 작업을 자신을 호출해 떠넘기는 재귀 함수를 작성가능하다. 이때, 남은 원소들을 고르는 작업을 다음과 같은 입력들의 집합으로 정의할 수 있다.

1. 원소들의 총 개수
2. 더 골라야 할 원소들의 개수
3. 지금까지 고른 원소들의 번호

```
// n : 전체 원소의 수
// picked : 지금까지 고른 원소들의 번호
// toPick: 더 고를 원소의 수
// 일때, 앞으로 toPick개의 원소를 고르는 모든 방법을 출력한다.
void pick(int n, int[] picked, int toPick){
    // 기저사례 : 더 고를 원소가 없을 때 고른 원소들을 출력
    if(toPick==0) { printPicked(picked); return;}
    // 고를 수 잇는 가장 작은 번호 계산
    int smallest = picked.empty() ? 0 : picked.back() + 1;
    // 이 단계에서 원소 하나를 고른다.
    for(int next = smallest; next<n; ++next){
        picked.push_back(next);
        pick(n,picked,topick-1);
        picked.pop_back();
    }
}
```

### **재귀 함수의 조건**

1. 모든 재귀함수는 '더이상 쪼개지지 않는' 최소한의 작업에 도달했을 때 답을 곧장 반환하는 조건문을 포함해야 한다. 즉, 기저 사례(base case)를 포함해야한다.


## **정렬**

정렬의 경우 정렬하고자 하는 개체의 수가 입력의 크기가 된다.

## **인접 행렬 vs 인접 리스트**

꼭짓점(vertex)가 적은 경우에만 인접 행렬 사용

## **StringTokenizer**

자바에서 String을 Token 단위로 끊어주는 기능 제공 

## **동적계획법**

### 정의

1. 복자한 문제를 간단한 여러 문제로 나누어 푸는 방법
2. 점화식 도출
3. 메모이제이션
